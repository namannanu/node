const express = require("express");
const multer = require("multer");
const { S3Client, PutObjectCommand, DeleteObjectCommand, ListBucketsCommand } = require("@aws-sdk/client-s3");
const { fromNodeProviderChain } = require("@aws-sdk/credential-providers");
const jwt = require('jsonwebtoken');
const User = require('../../users/user.model');

// Import S3 signed URL service
const { getSignedImageUrl, checkObjectExists, getMultipleSignedUrls } = require('../s3-signed-url.service');

const router = express.Router();

// In-memory storage for user uploads
const userUploads = new Map();

// JWT Secret
const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key-change-in-production';

// Middleware to verify JWT token
const verifyToken = (req, res, next) => {
    const authHeader = req.headers.authorization;
    const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN

    if (!token) {
        return res.status(401).json({ 
            success: false, 
            message: 'Access token is required' 
        });
    }

    try {
        const decoded = jwt.verify(token, JWT_SECRET);
        req.user = decoded;
        next();
    } catch (error) {
        return res.status(403).json({ 
            success: false, 
            message: 'Invalid or expired token' 
        });
    }
};

// Initialize S3 client
let s3;
let s3Available = false;

try {
    const awsConfig = {
        region: process.env.AWS_REGION || "ap-south-1"
    };

    if (process.env.AWS_ACCESS_KEY_ID && process.env.AWS_SECRET_ACCESS_KEY) {
        awsConfig.credentials = {
            accessKeyId: process.env.AWS_ACCESS_KEY_ID,
            secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY
        };
    }

    s3 = new S3Client(awsConfig);
    s3Available = true;
} catch (s3Error) {
    console.error("[ERROR] S3 client initialization failed:", s3Error.message);
    s3Available = false;
}

// Configure multer
const storage = multer.memoryStorage();
const upload = multer({
    storage: storage,
    limits: { fileSize: 10 * 1024 * 1024 }, // 10MB limit
    fileFilter: (req, file, cb) => {
        if (file.mimetype === "image/jpeg" || file.mimetype === "image/png" || file.mimetype === "image/jpg") {
            cb(null, true);
        } else {
            cb(new Error("Invalid file type. Only JPEG, JPG and PNG are allowed."), false);
        }
    }
});

// Upload Image Route
router.post("/upload", verifyToken, upload.single("image"), async (req, res) => {
    try {
        if (!req.file) {
            return res.status(400).json({ success: false, msg: "No file uploaded" });
        }

        const userId = req.user.userId;
        const fullname = req.body.fullname;
        
        if (!fullname || fullname.trim().length < 2 || fullname.length > 50) {
            return res.status(400).json({ 
                success: false, 
                message: "Invalid fullname. Must be between 2 and 50 characters." 
            });
        }

        const sanitizedFullname = fullname.replace(/[^a-zA-Z0-9\s]/g, '').replace(/\s+/g, '_');
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const filename = `${userId}_${sanitizedFullname}`;

        // Verify user exists first
        const user = await User.findOne({ userId: userId });
        if (!user) {
            return res.status(404).json({
                success: false,
                message: "User not found"
            });
        }

        // Check for existing upload
        if (userUploads.has(userId)) {
            const existingUpload = userUploads.get(userId);
            return res.status(409).json({
                success: false, 
                message: "You have already uploaded an image. Delete existing first.",
                existingUpload: {
                    filename: existingUpload.filename,
                    uploadedAt: existingUpload.uploadedAt,
                    fileUrl: existingUpload.fileUrl
                }
            });
        }

        if (!s3Available) {
            return res.status(503).json({ 
                success: false, 
                message: "S3 service unavailable" 
            });
        }

        // Upload to S3
        const params = {
            Bucket: "nfacialimagescollections",
            Key: `public/${filename}`,
            Body: req.file.buffer,
            ContentType: req.file.mimetype,
            Metadata: { 
                userId: userId,
                uploadedAt: timestamp
            }
        };

        await s3.send(new PutObjectCommand(params));
        const fileUrl = `https://nfacialimagescollections.s3.${process.env.AWS_REGION || 'ap-south-1'}.amazonaws.com/public/${filename}`;

        // Update user's uploadedPhoto field
        const updatedUser = await User.findOneAndUpdate(
            { userId: userId },
            { 
                $set: { 
                    uploadedPhoto: fileUrl,
                    updatedAt: new Date()
                }
            },
            { new: true }
        );

        if (!updatedUser) {
            return res.status(500).json({
                success: false,
                message: "Failed to update user record"
            });
        }

        // Store upload info in memory
        const uploadData = {
            filename,
            originalName: req.file.originalname,
            size: req.file.size,
            sizeMB: Math.round(req.file.size / (1024 * 1024) * 100) / 100,
            mimetype: req.file.mimetype,
            uploadedBy: sanitizedFullname,
            originalFullname: fullname,
            userId: userId,
            uploadedAt: timestamp,
            storage: "aws_s3",
            fileUrl: fileUrl,
            s3Key: `public/${filename}`
        };
        userUploads.set(userId, uploadData);

        // Return success response
        return res.status(200).json({
            success: true,
            fileUrl,
            storage: "aws_s3",
            message: "File uploaded to AWS S3 and user record updated successfully",
            uploadInfo: {
                filename,
                originalName: req.file.originalname,
                size: req.file.size,
                sizeMB: uploadData.sizeMB,
                uploadedBy: sanitizedFullname,
                userId: userId,
                uploadedAt: timestamp
            },
            user: {
                userId: updatedUser.userId,
                name: updatedUser.name,
                email: updatedUser.email,
                uploadedPhoto: updatedUser.uploadedPhoto,
                verificationStatus: updatedUser.verificationStatus,
                updatedAt: updatedUser.updatedAt
            },
            fileInfo: uploadData
        });

    } catch (error) {
        console.error("[ERROR] Upload Failed:", error);
        return res.status(500).json({
            success: false,
            message: "Upload failed",
            error: process.env.NODE_ENV === 'development' ? error.message : "Internal server error"
        });
    }
});

module.exports = router;
